Socket服务器对于资源的消耗会很浪费
虽然使用了线程池来解决并发的问题
    如果连接数并不是非常的多，这种模式会工作的很好
    如果连接数急剧上升，这种方式就不能很好的工作了，因为线程上下文切换开销会在高并发时突变的很明显，这是同步阻塞方式的低扩展性劣势

    NIO引入了多路复用技术，提供了另外一种思路

IO都是同步阻塞模式，所以需要多线程进行处理。而NIO则是利用了单线程轮询事件机制，通过高效地定位就绪的channel，来决定做什么，仅仅select阶段
是阻塞的，可以有效的避免大量客户端连接时，频繁切换线程带来的问题，应用的扩展性能有了非常大的提高

select模式是使用一个线程做监听，而bio每次来一个链接都要做线程切换，所以节省的时间在线程切换上，当然如果是C/C++实现，原理也是一样。

个人猜测：不考虑内核，应用层区分，单纯从代码角度考虑，我猜测，当select工作时，有一个定时器，比如每10秒去检查一下网络缓冲区中是否有tcp的链接请求包，
    然后把这些包筛选出来，作为一个集合（即代码中的迭代器）填入java select类的一个集合成员中，然后唤醒select线程，做一个while遍历处理链接请求，这样
    一次线程调度就可以处理10ms内所有链接。与bio相比，节省时间在线程上下文切换上。