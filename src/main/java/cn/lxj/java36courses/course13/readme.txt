谈谈接口和抽象类的区别？（面试）
回答：
1、接口和抽象类是java面向对象设计的基础机制。
2、接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到API定义和实现分离的目的。接口，不能实例化，不能包含任何非常量成员，任何field都是隐含着public static final的意义；
    同时，没有非静态方法实现，也就是说要么是抽象方法，要么是静态方法。Java标准类库中，定义了非常多的接口，比如java.util.List
3、抽象类是不能实例化的类，用abstract关键字修饰class，其目的主要是代码重用。除了不能实例化，形式上和一般的java类并没有太大的区别，可以有一个或者多个抽象方法，也可以没有抽象
    方法。抽象类大多用于抽取相关Java类的共用方法实现或者共同成员变量，然后通过继承的方式达到代码复用的目的。Java标准库中，比如Collection框架，很多通用部分被抽取成为抽象类，
    例如java.util.Abstract
4、Java类实现interface使用implements关键词，继承abstract class则是使用extends关键词。

    在一些特定的场景，需要抽象出具体实现，实例化无关的通用逻辑，或者纯调用关系的逻辑，但是使用传统的抽象类会陷入到单继承的窘境。以往常见的做法是，实现静态方法组成的工具类（Utils）
比如Java.util.Collections。

=============================================================================================
聊聊面向对象设计的基本方面：
1、面向对象的基本要素：封装、继承、多态。
    封装就是隐藏事务内部的实现细节，以便提高安全性和简化编程。封装提供了合理的边界，避免外部调用者接触到内部的细节。在日常开发中，因为无意中暴露了细节导致的难缠bug太多了，比如
    在多线程环境暴露内部状态，导致的并发修改问题。从另一个角度看，封装这种隐藏，也提供了简化的细节，避免太多无意义的细节浪费调用者的精力。

2、S.O.L.I.D原则：
    单一职责（Single Responsibility），类或者对象最好只有单一职责，在程序设计中如果发现某个类承担着多种义务，可以考虑进行拆分。

    开关原则（Open-Close，Open for expension，close for
    modification），设计要对扩展开放，对修改关闭。换句话说，程序设计应该保证平滑的扩展性，尽量避免因为新增同类功能而修改已有的实现，这样可以少出现回归（regression）问题。

    里氏替换原则（Liskov Substitute），这是面向对象的基本要素之一，进行继承关系抽象时候凡是可以用父类或者基类的地方，都可以用子类替换。

    接口分离（Interface
    Segregation
    ），我们在进行类和接口进行设计的时候，如果在一个接口定义了太多的方法，其子类很可能面临两难，就是只有部分方法对它是有意义的，这就破坏了程序的内聚性。可以通过拆分成单一的多个接口，将行为进行解耦，在未来维护中，如果某个接口设计有变，不会对使用其他接口的子类构成影响。

    依赖反转（Dependency Inversion），实体应该依赖于抽象而不是实现，也就是说高层次模块，不应该依赖于低层次的模块，而应该基于抽象。实践这一原则保证产品代码之间适当耦合度的法宝。

3、OOP原则实践中的取舍
    按照里式替换原则，我们经常这样定义变量：
        List<String> list = new ArrayList<String>();
    Java 10 中引入了本地方法类型推断和 var 类型：
        var list = new ArrayList<String>();
        但是list会被推断为ArrayList<String>
    理论上，这种语法上的便利，其实是增强了程序对实现的依赖，但是微小的类型泄漏却带来了书写的便利和代码可读性的提高，所以实践中我们要按照得失利弊进行选择，而不是一味的遵循原则。
    OOP原则注意开闭原则，将不同对象分类的服务方法进行抽象，把业务逻辑的紧耦合关系拆开，实现代码的隔离保证了方便的扩展。
