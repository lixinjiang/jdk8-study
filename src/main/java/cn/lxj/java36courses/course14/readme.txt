第十四讲    谈谈设计模式

设计模式目标分类：
    创建型模式、结构型模式和行为型模式
    1、创建型模式：是指对象创建过程中的各种问题的解决方案的总结，分为
        工厂模式（Factory、Abstract Factory）
        单例模式（Singleton）
        构建器模式（Builder）
        原型模式（Proto Type）
    2、结构型模式：针对软件设计结构的总结，关于类、对象继承、组合方式的时间经验。常见的结构型模式
        桥接模式（Bridge）
        适配器模式（Adapter）
        装饰者模式（Decorator）
        代理模式（Proxy）
        组合模式（Composite）
        外观模式（Facade）
        享元模式（Flyweight）
    3、行为模式：是从类或者对象之间交互、职责划分等角度总结的模式。比较常见的行为型模式有
        策略模式（Strategy）
        解释器模式（Interpreter）
        命令模式（Command）
        观察者模式（Observer）
        迭代器模式（Iterator）
        模板方法模式（Template Method）
        访问者模式（Visitor）

    参考：https://en.wikipedia.org/wiki/Design_Patterns

一、装饰器模式：本质上是包装同类型实例，我们对目标对象的调用，往往会通过包装类盖过的方法，迂回调用被包装的实例，这就可以很自然地实现增加额外逻辑
的目的，也就是所谓的装饰。
    例如：BufferedInputStream经过包装，为输入流过程增加缓存，类似这种装饰器还可以多次嵌套，不断地增加不同层次的功能。

二、工厂模式（创建型模式）：
    JDK最新版本中HTTP/2 Client API，下面这个创建HttpRequest的过程，就是典型的构建器模式（Builder），通常会被实现成fluent风格的API，也有人叫它方法链
    使用构建器模式，可以优雅的解决构建复杂对象的麻烦，这里的“复杂”是指类似需要输入的参数组合较多，如果用构造函数，我们往往需要为每一种可能的输入参数组合实现相应的构造函数
一系列复杂的构造函数会让代码阅读星和可维护性变得很差。

由于java中会为没有明确声明构造函数的类，定义一个public的无参数的构造函数，不能保证额外的对象被创造出来。所以可以为单例定义一个private构造函数（也有建议声明为枚举，这是有争议的，建议不选择相应复杂的枚举类型
    毕竟日常开发不是学术研究）
    在第十讲中，java的CurrentHashMap时，提过标准库中有很多懒加载（lazy-load），改善初始内存开销，单例同样适用
    例如：Singleton1，在单线程下不存在问题，但是处在并发的场景下，需要考虑线程安全的问题，最熟悉的莫过于“双检锁”，其主要在于：
        这里的Volatile能够提供可见性，以及保证getInstance返回的是初始化完全的对象。
        在同步之间进行null检查，以尽量避免相对昂贵的同步块
        直接在class级别进行同步， 保证线程安全的类方法调用
    Singleton2
    在现代java中，内存排序模型JVM已经非常完善了，通过volatile的write和read，能保证所谓的happen-before，也就是避免常被提到的指令重排。换句话说，构造对象的store指令能够保证一定在volatile
    read之前。
