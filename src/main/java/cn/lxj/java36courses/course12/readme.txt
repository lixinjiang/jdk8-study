Java的几种拷贝文件的方式以及最高效方式：

    对于copy效率来说，这个其实与操作系统和配置等情况相关，总体上来说，NIO tranferTo/From的方式可能更快，因为它能利用现代操作系统底层机制，避免
不必要的拷贝和上下文切换。

从技术角度展开：
    不同copy方式，底层机制由什么区别？
    为什么零拷贝（zero-copy）可能有性能优势？
    Buffer分类与使用
    Direct Buffer 对垃圾收集等方面的影响与实践选择

**********BIO**********
用户态空间：User Space——给普通用户和服务使用
内核态空间：Kernel Space——操作系统内核、硬件驱动等运行在内核态空间，具有相对高的特权；

当我们使用输入输出流进行读写操作的时候，首先在内核态，将磁盘上的内容读取到kernel缓存中，然后切换到用户态，将kernel缓存读取到用户缓存
当我们使用输入输出流进行写入操作的时候，首先在用户态，将内容写入用户缓存中，然后切换到内核态，将用户缓存写入到kernel缓存，kernel将缓存写入磁盘
***********************

*********NIO***********
用户态空间：User Space——给普通用户和服务使用
内核态空间：Kernel Space——操作系统内核、硬件驱动等运行在内核态空间，具有相对高的特权；

在Unix或着Linux中，则会使用零拷贝的技术，数据传输不需要用户态去参与，省去了上下文切换的开销和不必要的内存拷贝，进而可能提高应用拷贝的性能。
注意，transferTo不仅仅是可用在文件拷贝中，与其类似的，例如读取磁盘文件，然后进行Socket发送，同样可以享受这种机制带来的性能和扩展性提高。
始终是内核态进行读取磁盘然后进行kernel内核缓存，缓存通过transferTo拷贝到另一个kernel内核缓存然后输入到另一个磁盘。
***********************

对于堆外（Direct）内存Buffer。
应用如果出现内存不足，堆外内存占用也是一种可能性。在大多数垃圾收集过程中，都不会主动收集Direct Buffer，它的垃圾收集过程就是Cleaner（一个内部实现）
和幻像（PhantomReference）引用机制，其本身不是public类型，内部实现了一个Deallocator负责销毁逻辑。对它的销毁往往要拖到full GC的时候，所以使用不当很容易导致OutOfMemoryError。
对于Direct Buffer的回收，建议：
    在应用中，显示调用System.gc();来强制触发回收堆外内存。
    在大量使用Direct Buffer的部分框架中，框架会自己在程序中调用释放方法，Netty就是这么做的。
    重复使用Direct Buffer。

对于Direct Buffer内存诊断，在JDK1.8之后，可以使用Native Memory Tracking（NMT）特性来进行诊断，可以在启动时加上参数-XX:NativeMemoryTracking={summary|detail}
但是激活NMT通常会导致JVM性能5%~10%的性能下降。

